---
title:
tags:
notebook:C Programming
---

# MOOC浙大翁凯C语言程序设计

## 目录

[TOC]



### 5.1 for循环

for循环像一个计数循环：设定一个计数器，初始化它，然后在计数器到达某个值之前，重复执行循环体，而每执行一轮循环，计数器值以一定的步进进行调整，比如加1或者减1。

**for = 对于**

- for ( count=10; count>0; count-- )

- 就读成：对于一开始的count=10，当count>0时，重复做循环体，每一轮循环在做完循环体内语句后，使得count减1。

#### 计算阶乘n!（从1乘到n）

```c
#include <stdio.h>

int main() 
{
    int n;
    scanf("%d", &n);
    int fact = 1;
    //	计算阶乘
    int i = 1;
    for ( i=1; i<=n; i++) {//i=1是初始条件，i<=n是循环继续的条件，i++是循环每一轮要做到动作
        fact *= i;
    }
    printf("%d!=%d\n", n, fact);
    return 0;
}
```

==执行完一次循环后，i加1，比较当前i是否小于n，若小于或等于，则进入循环体==

**小套路**

- 做求和的程序时，记录结果的变量初始化为0；而做求积的变量时，记录结果的变量应该初始化为1。

- 若循环控制变量i只在循环里被使用，在循环外面它没有任何用处时，可以把变量i的定义写到for语句里面去。

    `for ( int i=1; i<=n; i++ )`	<u>***只有C99支持***</u>

#### 计算阶乘n!（从n乘到1）

```c
#include <stdio.h>

int main() 
{
    int n;
    scanf("%d", &n);
    int fact = 1;
    //	计算阶乘
    int i = n;	//记录n的初试值，用来输出所求是何数的阶乘
    for ( n=n; n>1; n--) {	//n=n可以省略，写成 for ( ; n>1; n--)
        fact *= n;
    }
    printf("%d!=%d\n", i, fact);
    return 0;
}
```

#### 循环的计算和选择

- `for ( i=0; i<n; i++ )`和`for ( i=1; i<=n; i++ )`的循环次数是一样的；不同的是，前者循环结束后i=n，后者i=n+1。
- for循环与while循环是等价的，任何一个for循环都可以改写成while循环
- for中的每一个表达式都是可以省略的，`for ( ; 条件;  )`==`while ( 条件 )`

#### Tips for loops

- 如果有固定的次数，用for
- 如果必须执行一次，用do-while
- 其他情况用while

### 5.2 循环控制

**素数**

```c
#include <stdio.h>

int main(int argc, const char * argv[])
{
    int x = 0;
    printf("请输入一个正整数：");
    scanf("%d", &x);
    
    int i = 0;
    int isprime = 1;    //x是素数
    for ( i=2; i<x; i++) {
        if ( x % i == 0 ) {
            isprime = 0;
            break;
        }
    }
    if ( isprime == 1) {
        printf("是素数。\n");
    } else {
        printf("不是素数。\n");
    }
    return 0;
}
```

利用`break;`语句可以跳出for循环或while或do-while。

`continue；`语句用来跳过这一轮循环剩下的语句进入下一轮循环。

<img src="https://zmq20200506.oss-cn-shanghai.aliyuncs.com/images/20200506234629.png?Lingting_Gun" style="zoom:30%;" />

#### 循环嵌套

**输出100以内的素数**

```c
#include <stdio.h>

int main() 
{
    int x;
    for ( x = 1; x <= 100; x++) {
        int i;
        int isprime = 1; //x是素数
        for ( i = 2; i < x; i++ ) {	//正常情况下每层循环用的控制变量不能相同
            if ( x % i == 0) {
                isprime = 0;
                break;
            }
        }
        if ( isprime == 1 ) {
            printf("%d ", x);
        }
    }
    return 0;
}
```

**输出前50个素数**

- for循环

```c
#include <stdio.h>

int main(int argc, const char * argv[]) 
{
    int x = 1;
    int cnt = 0;    //记录输出素数的个数
    
    for ( x = 1; cnt < 50; x++) {	//循环条件可以使cnt
        int isprime = 1;
        for ( i = 2; i < x; i++) {
            if ( x % i == 0) {
                isprime = 0;
                break;
            }
        }
        if ( isprime == 1 ) {
            cnt++;
            printf("%d\t", x);	//自动对齐
            if ( cnt % 5 == 0 ) {
                printf("\n");	//每输出5个结果，换行
            }
        }
    }
    return 0;
}
```

- while循环

```c
#include <stdio.h>

int main(int argc, const char * argv[]) {
    int x = 1;
    int cnt = 0;    //记录输出素数的个数

    while (cnt < 50) {
        int i;
        int isprime = 1;
        for (i = 2; i < x; i++) {
            if (x % i == 0) {
                isprime = 0;
                break;
            }
        }
        if (isprime == 1) {
            cnt++;
            printf("%d\t", x);
            if (cnt % 5 == 0) {
                printf("\n");
            }
        }
        x++;
    }
    return 0;
}
```

#### 离开多重循环

 **凑硬币--接力break**

```c
#include <stdio.h>

int main(int argc, const char * argv[]) {
    int x;  //  存储输入值
    int one, two, five; //  1毛，2毛，5m毛的个数
    int exit = 0;   //  是否退出循环标志位
    printf("请输入需要组成的金额：");
    scanf("%d", &x);
    
    for (one = 1; one < x * 10; one++) {
        for (two = 1; two < x * 10 / 2; two++) {
            for (five = 1; five < x * 10 / 5; five++) {
                if (one + two * 2 + five * 5 == x * 10) {
                    printf("%d个1毛，%d个2毛，%d个5毛可以组成%d元。\n", 
                           one, two, five, x);
                    exit = 1;
                    break;
                }
            }
            if (exit) break;
        }
        if (exit) break;
    }
    return 0;
}
```

**凑硬币--goto**

```c
#include <stdio.h>

int main(int argc, const char * argv[]) {
    int x;  //  存储输入值
    int one, two, five; //  1毛，2毛，5m毛的个数
    printf("请输入需要组成的金额：");
    scanf("%d", &x);

    for (one = 1; one < x * 10; one++) {
       for (two = 1; two < x * 10 / 2; two++) {
           for (five = 1; five < x * 10 / 5; five++) {
               if (one + two * 2 + five * 5 == x * 10) {
                   printf("%d个1毛，%d个2毛，%d个5毛可以组成%d元。\n", 
                          one, two, five, x);
                   goto out;    //  直接跳转到out处
               }
           }
       }
    }
out:
    return 0;
}
```

### 5.3高级循环应用

#### 分数求和

> $$
> f(n)= 1+\frac{1}{2}+\frac{1}{3}+...+\frac{1}{n}
> $$

```c
#include <stdio.h>

int main() 
{
    int n;	// 存储用户输入要求的n的值
    double sum = 0.0;	// 存储累加和
    printf("请输入n的值：");
    scanf("%d", &n);
    
    for (int i = 1; i <= n; i++) {
        sum += 1.0 / i;
    }
    
    printf("f(%d)=%f\n", n, sum);
    return 0;
}
```

$$
f(n)= 1-\frac{1}{2}+\frac{1}{3}-\frac{1}{4}+...+\frac{1}{n}
$$

```c
#include <stdio.h>

int main() 
{
    int n;
    double sum = 0.0;
    printf("请输入n的值：");
    scanf("%d", &n);
    
    double sign = 1.0;	// 用sign来实现正负间隔，同时设为浮点型，保证运算
    for (int i = 1; i <= n; i++) {
        sum += sign / i;
        sign = -sign;
    }
    printf("f(%d)=%f\n", n, sum);
    return 0;
}
```

#### 整数分解

**正序分解整数**

- 输入一个非负整数，正序输出它的每一位数字
- 输入：13425
- 输出：1 3 4 2 5 

```c
#include <stdio.h>

int main() 
{
    int x;
    printf("请输入需要拆分的非负整数：");
    scanf("%d", &x);
//  求出用来取最高位的除数mask
    int mask = 1;
    int t = x;
    while (t > 9) {     //  保证只有一位数时，mask为1
        mask *= 10;
        t /= 10;
    }
//  printf("t = %d，mask = %d\n", t, mask);  //  测试当前t和mask的值
//  顺序输出整数
    do {
        int d = x / mask;
        printf("%d", d);    //  输出当前最高位
        if (mask > 9) {     //  不是最后一位时，在输出位后输出一个空格
            printf(" ");
        }
        x %= mask;
        mask /= 10;
    } while (mask > 0);
    printf("\n");
    return 0;
}
```

#### 求最大公约数

**枚举法**

```c
#include <stdio.h>

int main() 
{
    int a, b;
    int min;
    scanf("%d %d", &a, &b);
//  找到两个数中较小的那个数
    if (a < b) {
        min = a;
    } else {
        min = b;
    }
//  枚举法求最大公约数
    int ret = 0;
    for (int i = 1; i < min; i++) {
        if (a % i == 0) {
            if (b % i == 0) {
                ret = i;
            }
        }
    }
    printf("%d和%d的最大公约数为%d。\n", a, b, ret);
    return 0;
}

```

**辗转相除法**

1. 如果b等于0，计算结束，a就是最大公约数；
2. 否则，计算a除以b的余数，让a等于b，而b等于那个余数；
3. 回到第一步；

```c
#include <stdio.h>

int main() 
{
    int a, b;
    int t;	//	存储a除以b的余数
    printf("请输入两个数：");
    scanf("%d %d", &a, &b);
//	辗转相除
    while (b != 0) {
        t = a % b;
        a = b;
        b = t;
    }
    printf("最大公约数为%d。\n", a);
    return 0;
}
```

#### 编程练习解析

**例题一：求序列前n项和**

计算序列2/1+3/2+5/3+8/5...的前n项和。注意该序列从第二项起，每一项的分子是前一项分子与分母的和，分母是前一项的分子。

**输入格式：**

输入在一行中给出一个正整数N。

**输出格式：**

在一行中输出部分和的值，精确到小数点后2位。题目保证计算结果不超过双精度范围。

**输入样例：**



**输出样例：**

32.66

```

```

### 6.1 数据类型

#### C语言是有类型的语言

- C语言的变量，必须：
    - 在使用前定义，并且确定类型
- C以后的语言向两个方向发展：
    - C++/Java更加强调类型，对类型的检查更严格
    - JavaScript、Python、PHP不看重类型，甚至不需要事先定义

**类型安全**

- 支持强类型的观点认为明确的类型有助于尽早发现程序中的简单错误
- 反对强类型的观点认为过于强调强类型迫使程序员面对底层，而非实现事务逻辑
- 总的来说，早期的语言强调类型，面向底层的语言强调类型
- C语言需要类型，但是对类型的安全检查并不足够

##### C语言的类型

- 整数
    - char、short、int、long、long long(C99)
- 浮点数
    - float、double、long double(C99)
- 逻辑
    - bool
- 指针
- 自定义类型

##### 类型有何不同

- 类型名称：int、long、double
- 输入输出时的格式化：%d、%ld、%lf
- 所表达的数的范围：char < short < int < float < double
- 内存中所占据的大小：1个字节(char)到16个字节(long double)
- 内存中的表达形式：整型为二进制数（或补码）、浮点型为编码

#### sizeof

- 是一个运算符，给出某个类型或变量在内存中所占据的字节数
    - `sizeof(int)`
    - `sizeof(i)`
- 是静态运算符，它的结果在编译时就决定了
- 不要再sizeof的括号里做运算，这些运算是不会做的

#### 整数

- char：1字节（8比特）
- short：2字节
- int：取决于编译器（CPU），通常的意义是“一个字”
- long：取决于编译器（CPU），通常的意义是“一个字”
- long long：8字节

*<u>计算机的位数或字长是指计算器CPU中的寄存器是多少bit，即每个寄存器最多可以表达多少个bit的数据；同时也是在说内存RAM和CPU之前传输的数据每次可以传输多少比特，即总线每次可以传输多少bit。通常有32bit和64bit，一般计算机中的int可能为32bit(4字节)或64bit(8字节)。</u>*

##### *整数的内部表达

- 计算机内部一切都是二进制
    - 18—>00010010
    - 0—>00010010

##### *二进制负数

- 1个字节可以表达的数：
    - 0000 0000 — 1111 1111（0-255）
- 三种方案
    - 仿照十进制，有一个特殊的标志表示负数【***需要判断特别的标志，导致设计复杂***】
    - 取中间的数为0，如1000 0000表示0，比它小的是负数，比它大的是正数【***每次都需要与10000000做减法，判断自己到底是多少***】
    - 补码

##### *补码

- 考虑-1，我们希望-1 + 1 —> 0。
    - 0—>0000 0000
    - 1—>0000 0001
    - 1111 1111 + 0000 0001 = 1 0000 0000
- 因为0 - 1 —> -1，所以，-1 =
    - (1)0000 0000 - 0000 0001 —> 1111 1111
    - 1111 1111被当作纯二进制看待时，是255，被当作补码看待时是-1
- 同理，对于-a，其补码就是0-a，实际是2^n^-a，n是这种类型的位数

==补码的意义就是拿补码和原码可以加出一个溢出的“零”==

**数的范围**

- 对于一个字节（8位），可以表达的是：
    - 0000 0000 - 1111 1111
- 其中
    - 0000 0000 —> 0
    - 1111 1111 ~ 1000 0000 —> -1 ~ -128
    - 0000 0001 ~ 0111 1111 —> 1 ~ 127

```c
#include <stdio.h>

int main() 
{
    char c = 255;
    int i = 255;
    printf("c=%d，i=%d\n", c, i);
    //  c其实是：11111111，对c来说它的最高位为1
    //  i其实是：00000000 00000000 00000000 11111111，对i来说最高位不是1
    return 0;
}
```

##### 整数的范围

- char：1字节：-128 ~ 127
- short：2字节：-32678 ~ 32767
- int：取决于编译器（CPU），通常的意义是“一个字”
- long：4字节：-2^32-1^ ~   2^32-1^-1
- long long：8字节

##### unsigned

- 如果一个字面量常数想要表达自己是unsigned，可以在后面加u或U
    - 255U
- 用l或L表示long（long）
- *unsigned的初衷并非是为了扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位

##### 整数越界

- 整数是以纯二进制方式进行计算的，所以：
    - 1111 1111 + 1 —> 1 0000 0000 —> 0
    - 0111 1111 + 1 —> 1000 0000  —> -128
    - 1000 0000 - 1 —> 0111 1111 —> 127

##### 整数的输入输出

只有两种形式：int或long long

- %d：int和比int小的char或short输出时，都是%d
- %u：unsigned int、unsigned char、unsigned short

==当把小于int的变量传给printf时，编译器会把这个变量转换为int传进去==

- %ld：long和long long输出时，都是%ld
- %lu：unsigned long、unsigned long long

##### 8进制和16进制

- 一个以0开始的数字字面量是8进制
- 一个以0x开始的数字字面量是16进制
- %0用于输出8进制，%0x或%0X用于输出16进制

==8进制和16进制知识如何把数字表达为字符串，与内部如何表达数字无关，计算机内部都是表达为2进制==

##### 整数类型的选择

- 为什么整数要有那么多种？
    - 为了准确表达内存，做底层程序的需要
- 没有特殊需要，就选int
    - 现在的CPU的字长普遍是32位或64位，一次内存读写就是一个int，一次计算也是一个int，选择更短的类型不会更快，为了剥离多余位，有时甚至可能更慢
    - *现代的编译器一般会设计内存对齐，所以更短的类型实际在内存中可能也占据一个int的大小（虽然sizeof告诉你更小）
- unsigned与否只是输出的不同，内部计算是一样的

#### 浮点类型

|  类型  | 字长 |                            范围                            | 有效数字 |
| :----: | :--: | :--------------------------------------------------------: | :------: |
| float  |  32  |  ±(1.20×10^-38^~3.40×10^38^)，0，±inf(∞)，nan(非有效数字)  |    7     |
| double |  64  | ±(2.20×10^-308^~1.79×10^308^)，0，±inf(∞)，nan(非有效数字) |    15    |

- -10^-38^ ~ 0 ~ 10^-38^中间的数无法用float表达，不包括0
- -10^-308^ ~ 0 ~ 10^-308^中间的数无法用double表达，不包括0

|  类型  | scanf |            printf            |
| :----: | :---: | :--------------------------: |
| float  |  %f   | %f，%e或%E(输出为科学计数法) |
| double |  %lf  | %f，%e或%E(输出为科学计数法) |

在%和f之间加上.n可以致电过输出小数点后几位数字，但这样的输出是四舍五入的：`printf("%.16f\n", a)	//	在小数点后输出16位的数字`

```c
#include <stdio.h>

int main() 
{
    printf("%.3f\n", -0.0049);	//	输出为：-0.005
    printf("%.30f\n", -0.0049);	//	输出为：-0.004899999999999999841793218991
    printf("%.3f\n", -0.00049);	//	输出为：-0.000
    return 0;
}
```

 

```c
#include <stdio.h>

int main() 
{
    printf("%f\n", 12.0 / 0.0);	//	输出为：inf
    printf("%f\n", -12.0 / 0.0);	//	输出为：-inf
    printf("%f\n", 0.0 / 0.0);	//	输出为：nan
    return 0;
}
```

##### 浮点运算精度

```c
float a, b, c;

a = 1.345f;
b = 1.123f;
if (c == 2.468)
    printf("相等\n");
else
    printf("不相等！c=%.10f，或%f\n", c, c);	
	//	输出为：不相等！c=2.4679999352，或2.468000
```

- ==带小数点的字面量是默认是double而非float，float需要用f或F后缀来表明身份==
- ==f1 ==  f2可能失败，通常用fabs(f1 - f2) < 1e-8或fabs(f1 - f2) < 1e-12，即求两个浮点数的差的绝对值,看他是否小于float能表达的精度==

##### *浮点数的内部表达

<img src="/Users/kungfu/Library/Application Support/typora-user-images/截屏2020-03-0818.00.54.png" alt="截屏2020-03-0818.00.54" style="zoom:85%;" />

在浮点数内部，不是一个真正的二进制数，而是一个编码的形式：

- 第1个bit用来表达正负
- 2~11个bit用来表达指数部分
- 后面的bit用来表达分数部分

==浮点数在计算时是由专用道硬件部件实现的。计算double和float所用的部件是一样的。==硬件接收到编码后先解码做运算，然后再编码返回给用户。

##### 浮点类型的选择

- 如果没有特殊需要，只使用double
- 现代CPU能直接对double做硬件计算，性能不会比float差，在64位的机器上，数据存储的速度也不比float慢。

#### 字符类型

- char是一种整数，也是一种特殊的类型：字符（character）。
    - printf和scanf里用%c来输入输出字符 

- 输入'1'这个字符给`char c`

```c
char c;
scanf("%c", %c);
```

​	此时输入1

```c
char c;
int i;
scanf("%d", &i);
c = i;
```

​	此时需输入49

```c
 printf("c='%c',c=%d\n", c, c);	//	输出均为：c='1',c=49
```

***因为'1'的ASCII码是49，所以当c == 49时，它代表'1'*** 

`scanf("%d %c", &i, &c);`和`scanf("%d%c", &i, &c);`的区别

输入：`12 1`

```c
int i;
char c;
scanf("%d %c", &i, &c);	//	%d后面有空格
printf("i=%d, c='%c', c=%d\n", i, c, c);	//	输出为：i=12, c='1', c=49
```

```c
int i;
char c;
scanf("%d %c", &i, &c);	//	%d后面有空格
printf("i=%d, c='%c', c=%d\n", i, c, c);	//	输出为：i=12, c=' ', c=32
```

- 若%d后面有空格，则整数要读到空格结束，包括空格，空格后的内容读给%c；若整数后面没有空格，则读接下来的内容默认为字符
- 若%d后面没有空格，则整数读完以后默认继续读下一个字符给%c，下一个字符可能为输入的空格

##### 字符计算

- 一个字符加一个数字得到ASCII码表中那个数之后的字符
- 两个字符的减，得到它们在表中的距离
- 'a'-'A'可以得到两段之间的距离，于是：
    - a + 'a'-'A' 可以把一个大写字母变成小写字母【大变小，小减大】
    - a + 'A'-'a' 可以把一个小写字母变成大写字母【小变大，大减小】

=='A'：65、'a'：97==

##### 逃逸字符

- 用来表达无法印出来的控制字符或特殊字符，它由一个反斜杠“\”开头，后面跟上另一个字符。这两个字符组合起来，组成了一个字符。

| 字符 |      意义      | 字符 |    意义    |
| :--: | :------------: | :--: | :--------: |
|  \b  |    回退一格    | \\"  |   双引号   |
|  \t  | 到下一个表格位 | \\'  |   单引号   |
|  \n  |      换行      | \\\  | 反斜杠本身 |
|  \r  |      回车      |      |            |

#### 类型转换

##### 自动类型转换

- 当运算符的两边出现不一致的类型时，会自动转换成较大的类型
- - char —> short —> int —> long —> long long
    - int —> float —> double
- 对于printf，任何小于int的类型会被转换成int；float会被转换成double
- 但是scanf不会，要输入short，需要%hd；要输入int，需要%d；要输入long或long long，需要%ld；

##### 强制类型转换

- 要把一个量强制转换成另一个类型（通常是较小的类型），需要：
    - （类型）值
        - `(int)10.2`
        - `(short)32`
    - 注意这时候的安全性，小的变量不能总表达大的量
        - `(short)32768`会输出`-32768`，因为short最大为32767
        - `(char)32768`会输出`0`，因为char只有8个bit，而32768 = 10……0(15个0)，对char来说取了最低的8个bit，全都是0。
- ==强制类型转换只是从那个变量计算出了一个新的类型的值，它并不改变那个变量，无论是值还是类型都不改变==

- 强制类型转换优先级高于四则运算

### 6.2 其他运算

#### 逻辑类型

- `#include<stdbool.h>`之后就可以使用bool和true、false

##### 逻辑运算

- 逻辑运算是对逻辑量进行的运算，结果只有0或1
- 逻辑量是关系运算或逻辑运算的结果

| 运算符 |  描述  |   示例   |                            结果                            |
| :----: | :----: | :------: | :--------------------------------------------------------: |
|   ！   | 逻辑非 |    !a    |     如果a是true结果就是false，如果a是false结果就是true     |
|   &&   | 逻辑与 |  a && b  |       如果a和b都是true，结果就是true；否则就是false        |
|  \|\|  | 逻辑或 | a \|\| b | 如果a和b有一个true，结果为true；两个都是false，结果为false |

**优先级**

- ! > && > ||

- 逻辑运算是自左向右进行的，如果左边的结果已经能够决定结果了，就不会做右边的计算，这种事请叫做：短路
    - 对于&&，左边是false时就不做右边了
    - 对于||，左边是true时就不做右边了
    - 所以尽量不要把赋值运算表达式写在右边

#### 条件运算符

- `count = (count > 20) ? count - 10 : count + 10`

- `=`后面`?`前面是条件、`?`后面时条件满足时的值、`:`后面是条件不满足时的值

- 等价于

    - ```c
        if (count > 20) {
            count = count - 10;
        } else {
            count = count + 10;
        }
        ```

==一般不建议使用嵌套的条件表达式==

#### 逗号运算

- 逗号用来连接两个表达式，并以其右边的表达式的值作为它的结果。逗号的优先级是所有运算符中最低的，所以它两边的表达式会优先运算；逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果。

    - `i = 3 + 4, 5 + 6;` 输出的i=7
    - `i = (3 + 4, 5 + 6);` 输出的i=11

- 逗号运算一般只在for循环中使用

    - ```c
        for (i = 0, j = 10; i < j; i++, j--)
        ```

### 7.1 函数的定义和调用

#### 初见函数

- ***代码复制***是程序质量不良的表现

**求和**

```c
void sum(int begin, int end) 
{
    int i;
    int sum;
    for (i = begin; i <= end; i++){
        sum += i;
    }
    printf("%d到%d的和是%d。\n", begin, end, sum);
}

int main()
{
    sum(1, 10);
    sum(20, 30);
    sum(35, 45);
    return 0;
}
```

#### 函数的定义和调用

##### 什么是函数

- 函数是一块代码，接收零个或多个参数，做一件事，并返回零个或一个值
- 可以先想象成数学中的函数

##### 函数定义

```c
函数头：返回类型 函数名（参数表）//	参数之间用','分开
{
	函数体
}
```

##### 调用函数

- ()起到了表示函数调用的重要作用
    - 即使没有参数也需要()

- 如果有参数，则需要给出正确的数量和顺序，这些值会被按照顺序依次用来初始化函数中的参数

- 函数知道每一次是哪里调用它，会返回到正确的地方

#### 从函数中返回值

- return停止函数的执行，并送回一个值
    - return后面可以不跟变量`return;`，也可以跟表达式`return 表达式`

- 可以复制给变量
- 可以再传递给函数
- 甚至可以丢掉

**没有返回值的函数**

`void 函数名(参数表)`

- 不能使用带值的`return`
    - 可以没有`return`
- 调用的时候不能做返回值的赋值
- ==如果函数有返回值，就必须使用带值的`return`==

### 7.2 函数的参数和变量

#### 函数原型

**函数先后关系**

- c的编译器自上而下顺序分析你的代码，所以main函数内需要调用的函数需要在上面先定义
- 即，需要先定义函数原型
    - 函数头，以分号';'结尾，就构成了函数的原型
- 函数原型的目的是告诉编译器这个函数长什么样子
    - 名称
    - 参数（数量及类型），可以不写参数的名字，但需要类型`void sum(int , int ); `
    - 返回类型

```c
#include<stdio.h>

void sum(int begin, int end); 	//函数原型，声明

int main()
{
    sum(1, 10);
    sum(20, 30);
    sum(35, 45);
    return 0;
}

void sum(int begin, int end) 	//	实际的函数头
{
    int i;
    int sum;
    for (i = begin; i <= end; i++){
        sum += i;
    }
    printf("%d到%d的和是%d。\n", begin, end, sum);
}
```

#### 参数传递

##### 函数调用

- 如果函数有参数，调用函数时必须传递给它数量、类型正确的值
- 可传递给函数的值是表达式的结果，这包括：
    - 字面量
    - 变量
    - 函数的返回值
    - 计算的结果

##### 类型不匹配

- 调用函数是给的值与参数的类型不匹配是C语言传统上最大的漏洞
- 编译器总是悄悄替你把类型转换好，但是这很可能不是你所期望的
- 后续的语言，C++/Java在这方面很严格

##### 调用函数时，传过去的是什么？

==C语言在调用函数时，永远只能传值给函数==

- 每个函数有自己的变量空间，参数也位于这个独立的空间中，和其他函数没有关系
- 函数参数表中的参数和调用函数时给的值就是***<u>参数和值</u>***的关系

#### 本地变量

- 函数的每次运行，就产生了一个独立的变量空间，在这个变量空间中的变量，是函数的这次运行所独有的，称作 *本地变量*  或 *局部变量*  或 *自动变量*
- 定义在函数内部的变量就是本地变量
- 参数也是本地变量

##### 变量的生存期和作用域

- 生存期：什么时候这个变量开始出现，到什么时候它消亡了
- 作用域：在（代码的）什么范围内可以访问这个变量（这个变量可以起作用）
- 对于本地变量，这两个问题的答案是统一的：大括号内——块

##### 本地变量的规则

- 本地变量是定义在块内的

    - 它可以是定义在函数的块内

        ```c
        swap(a, b)
        {
            int x = 0;
        }
        ```

    - 也可以是定义在语句的块内

        ```c
        if (a < b) {
            int i = 10;
        }
        ```

    - 甚至可以随便拉一个大括号来定义变量

- 程序运行进入这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了

- 块外面定义的变量在里面仍然有效

    ```c
    int main()
    {
        int a = 5;
        int b = 6;
        {
            int i = 0;
            printf("%d\n", a);	//	会输出：5
        }
    }
    ```

- 块里面定义了和外面同名的变量则掩盖了外面的

    ```c
    int main()
    {
        int a = 5;
        int b = 6;
        {
            int a = 0;
            printf("a=%d\n", a);	//	会输出：a=0
        }
    }
    ```

- 不能在一个块内定义同名的变量

- 本地变量不会被默认初始化

- 参数在进入函数的时候被初始化了

#### 其他细节

##### 没有参数时

- 建议将声明写成`void f(void);`
- `void f();`在传统的C中，他表示f函数的参数表未知，并不表示没有参数

##### 逗号运算符

- 调用函数时，圆括号里面的逗号是标点符号，不是运算符：`f(a, b)`;
- 但如果是`f((a,b));`则需要算逗号运算再将计算结果传入函数

##### 函数里的函数？

- ==C语言不允许函数嵌套定义==

##### 关于main

- `int main()`也是一个函数，可以写成`int main(void)`
- `return 0;`是有用的，操作系统可以用来判断程序的运行结果
    - Windows：if errorlevel 1……
    - Unix Bash：echo $?
    - Csh：echo $status

